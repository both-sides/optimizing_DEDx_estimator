#!/usr/bin/env python3
import argparse
import ROOT
ROOT.gStyle.SetOptStat(0)
ROOT.EnableImplicitMT()   # optional speed-up on multicore

# ---------- CLI ----------
ap = argparse.ArgumentParser(description="Cumulative selection efficiency table")
ap.add_argument("-i","--input", required=True, help="input ROOT file")
ap.add_argument("-t","--tree",  required=True, help="tree name, e.g. Events")
ap.add_argument("--weight", default=None, help="event weight branch (optional)")
ap.add_argument("--csv",    default="cumulative_efficiencies.csv", help="output CSV path")
args = ap.parse_args()

# ---------- Branch names (edit to match your ntuples) ----------
HLT_BOOL         = "HLT_Mu50"
PT               = "IsoTrack_pt"
ETA              = "IsoTrack_eta"                        # if you don't have it, remove that cut below
FRAC_VALID       = "IsoTrack_fractionOfValidHits"
HIGH_PUR         = "IsoTrack_isHighPurityTrack"
NORM_CHI2        = "IsoTrack_normChi2"
DXY              = "IsoTrack_dxy"
DZ               = "IsoTrack_dz"
PIXELS_L2L4      = "DeDx_PixelNoL1NOM"
NDEDX            = None  # e.g., "IsoTrack_nDeDx"; set if available

# ---- Define the sequential *per-track* cuts (same track accumulates cuts) ----
track_cuts = [
    ("pT > 55 GeV",                   f"({PT} > 55)"),
    ("|eta| < 1",                     f"(ROOT::VecOps::abs({ETA}) < 1)"),
    ("# valid pixel hits L2-L4 >= 2", f"({PIXELS_L2L4} >= 2)"),
    ("Fraction of valid hits > 0.8",  f"({FRAC_VALID} > 0.8)"),
    # ("# dE/dx measurements >= 10",  f"({NDEDX} >= 10)") if NDEDX else None,
    ("High-purity track",             f"{HIGH_PUR}"),
    ("Track chi2/ndf < 5",            f"({NORM_CHI2} < 5)"),
    ("|dz| < 0.1 cm",                 f"(ROOT::VecOps::abs({DZ})  < 0.1)"),
    ("|dxy| < 0.02 cm",               f"(ROOT::VecOps::abs({DXY}) < 0.02)"),
]
# Remove any None entries (e.g., if NDEDX is None)
track_cuts = [c for c in track_cuts if c is not None]

# ---------- Open file / build RDataFrame ----------
f = ROOT.TFile.Open(args.input)
if not f or f.IsZombie():
    raise RuntimeError(f"Could not open {args.input}")

# Try to get a TTree by full path (e.g. 'HSCPFullAODAnalyzer/Events').
obj = f.Get(args.tree)

if obj and obj.InheritsFrom("TTree"):
    # Got the tree pointer from the directory path
    tree = obj
    df = ROOT.RDataFrame(tree)
else:
    # Fallback: let RDataFrame open by name+file (works for top-level trees)
    # and also works if args.input is a filename glob or comma-separated list.
    try:
        df = ROOT.RDataFrame(args.tree, args.input)
    except Exception as e:
        # Helpful diagnostics: list available trees/paths
        f.ls()
        raise RuntimeError(
            f"Could not find tree '{args.tree}' in {args.input}. "
            "If your tree is under a TDirectory, pass the full path, e.g. "
            "'-t HSCPFullAODAnalyzer/Events'."
        ) from e


# ---------- Count "All events" (weighted or unweighted) ----------
def count_events(dframe):
    return (float(dframe.Sum(args.weight).GetValue())
            if args.weight else int(dframe.Count().GetValue()))

N0 = count_events(df)          # All events
rows = [("All events", N0, 1.0 if N0>0 else 0.0)]

# ---------- Apply trigger (event-level) ----------
dfe = df.Filter(HLT_BOOL, "Trigger")
N1 = count_events(dfe)
rows.append(("Trigger", N1, (N1/N0 if N0>0 else 0.0)))

# ---------- Build cumulative per-track mask and reduce with Any(mask) ----------
cum_mask = None
for label, expr in track_cuts:
    cum_mask = expr if cum_mask is None else f"({cum_mask}) && ({expr})"
    df_k = dfe.Filter(f"ROOT::VecOps::Any({cum_mask})", label)
    Nk = count_events(df_k)
    eff = (Nk / N0) if N0>0 else 0.0
    rows.append((label, Nk, eff))

df_final = dfe.Filter(f"ROOT::VecOps::Any({cum_mask})", "Final selection")
N_final = (df_final.Sum(args.weight).GetValue() if args.weight else df_final.Count().GetValue())
print("\nEvents after full selection:", N_final)

# ---------- Pretty print to terminal ----------
# Using only the standard library:
def fmt_row(name, events, eff):
    return f"{name:<32} {events:>12}   {100.0*eff:6.3f} %"

print("\nCUMULATIVE SELECTION EFFICIENCY\n")
print(f"{'Selection':<32} {'Events':>12}   {'Eff. (cum to All)':>16}")
print("-"*65)
for name, events, eff in rows:
    print(fmt_row(name, events, eff))
print("-"*65)

# ---------- Save CSV ----------
import csv
with open(args.csv, "w", newline="") as out:
    w = csv.writer(out)
    w.writerow(["Step", "CumulativeSelection", "Events", "Efficiency"])
    for i,(name, events, eff) in enumerate(rows):
        w.writerow([i, name, events, eff])
print(f"Saved: {args.csv}")
